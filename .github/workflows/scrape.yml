name: Scrape Runner

on:
  workflow_dispatch:
    inputs:
      job_id:
        description: 'Supabase job ID for tracking'
        required: true
        type: string
      skus:
        description: 'Comma-separated list of SKUs to scrape'
        required: false
        type: string
      scrapers:
        description: 'Comma-separated list of scraper names to run'
        required: false
        type: string
      test_mode:
        description: 'Run in test mode'
        required: false
        type: boolean
        default: false
      max_workers:
        description: 'Maximum number of concurrent workers'
        required: false
        type: number
        default: 3

# Only run on self-hosted runners with Docker
jobs:
  scrape:
    runs-on: [self-hosted, docker]
    timeout-minutes: 60
    environment: production

    env:
      # API-driven configuration - NO database credentials!
      SCRAPER_API_URL: ${{ secrets.SCRAPER_API_URL }} # actionlint-disable-line
      SCRAPER_WEBHOOK_SECRET: ${{ secrets.SCRAPER_WEBHOOK_SECRET }} # actionlint-disable-line
      # Legacy callback URL (now handled by runner.py internally)
      CALLBACK_URL: ${{ secrets.SCRAPER_CALLBACK_URL }} # actionlint-disable-line

      JOB_ID: ${{ inputs.job_id }}

    steps:
      - name: Run scraping job in Docker
        id: scrape
        env:
          RUNNER_NAME: ${{ runner.name }}
        run: |
          echo "Starting job: $JOB_ID"
          echo "Runner: $RUNNER_NAME"
          
          # Run the API-driven runner module
          # The runner fetches config from API, executes scraping, and submits results
          docker run --rm \
            -e SCRAPER_API_URL="$SCRAPER_API_URL" \
            -e SCRAPER_WEBHOOK_SECRET="$SCRAPER_WEBHOOK_SECRET" \
            -e RUNNER_NAME="$RUNNER_NAME" \
            baystate-scraper:latest \
            python -m scraper_backend.runner --job-id "$JOB_ID" --runner-name "$RUNNER_NAME" \
            > /tmp/scrape_results.json

      - name: Report failure
        if: failure()
        env:
          RUNNER_NAME: ${{ runner.name }}
        run: |
          # Runner.py handles normal result submission
          # This step only runs if Docker itself fails (out of memory, crash, etc.)
          PAYLOAD=$(jq -n \
            --arg job_id "$JOB_ID" \
            --arg runner_name "$RUNNER_NAME" \
            '{job_id: $job_id, status: "failed", runner_name: $runner_name, error_message: "Docker container failed - check GitHub Actions logs"}')
          
          SIGNATURE=$(echo -n "$PAYLOAD" | openssl dgst -sha256 -hmac "$SCRAPER_WEBHOOK_SECRET" | awk '{print $2}')
          
          curl -X POST "$CALLBACK_URL" \
            -H "Content-Type: application/json" \
            -H "X-Webhook-Signature: $SIGNATURE" \
            -d "$PAYLOAD"

